### AVL Tree

AVL Tree는 어떤 node이건 좌/우의 height 차가 -1, 0, 1로 균형을 맞추는 tree

여기서 우선 회전에 대해 알아간 후 에 RB Tree로 넘어가보자.

### RB Tree

#### 규칙/특성

1. 모든 node는 Red 또는 Black의 색을 갖는다

2. 모든 Null Pointer는 Black의 색을 갖는다고 가정한다

3. Root는 무조건 Black의 색을 갖는다

4. 어떤 node가 Red라면 그 자식은 무조건 Black이어야 한다

5. Root로부터 시작되는 모든 leaft로의 경로에는 같은 수의 Black node를 가져야 한다

   

#### 삽입

삽입되는 node는 기본적으로 red이다. 이 후 RB tree의 특성을 유지하기 위해 조정한다.

1. Root로 삽입

   처음 삽입된 node는 red로, root에 위치하게 된다. 이 때 3번 특성을 유지하기 위해 black으로 바꾸어준다.

2. 부모가 Black인 경우

   부모가 black인 경우, RB tree의 규칙을 모두 유지하고 있으므로 그대로 있는다.

3. 부모가 R, 삼촌이 R인 경우

   부모가 R이라면, 조부모는 B이다. 따라서 조부모를 R로 바꾸고 부모, 삼촌을 B로 바꾼다.

   --> 조부모가 R로 바뀌어서 깨지는 규칙은 조부모를 삽입했다고 생각하고 규칙 맞추기

4. 부모가 R, 삼촌이 B인 경우

   4-1 자식 -> 부모 -> 조부모가 1자일 때

   ​		부모와 조부모의 색을 바꾸고 방향대로 1번 회전

   4-2 자식 -> 부모 -> 조부모가 1자가 아닐 때

   ​		자식과 조부모의 색을 바꾸고 자식 -> 부모 -> 조부모를 1자로 펴기 위해 1번 회전 후

   ​		자식 -> 부모 -> 조부모 방향대로 1번 회전



### AVL Tree vs RB Tree

- AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 Red-Black 트리보다 더 빠른 조회를 제공

- Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입 및 제거 작업을 수행(작은 데이터의 경우.)

  하지만 data가 굉장히 큰 경우 삽입 및 제거 작업시 조회를 우선으로 해야 하기 때문에 AVL 트리가 조금 더 유리해진다. 하지만 최악의 경우에는 balance를 유지할 때 AVL 트리에서 또 지체될 가능성도 있다.

- AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요
  Red-Black 트리는 노드당 1비트의 정보만 필요.

- Red-Black 트리는 맵, C++의 멀티캐스트, Java treeMap 등 대부분의 언어 라이브러리에서 사용.

  AVL트리는 더 빠른 검색이 필요한 데이터베이스에서 사용



### B Tree

하나의 노드에 여러 데이터를 가지는 형태